#!/usr/bin/env ts-node-script
import { SandbarApiService } from "../generated/private/sandbar"
import { HttpRule } from "../generated/private/google/api/http"
import { IMessageType } from "@protobuf-ts/runtime"
import { readMethodOption } from "@protobuf-ts/runtime-rpc"
import path from "path"
import { Readable, pipeline } from "stream"
import fs from "fs"
import { promisify } from "util"
const pipelineAsync = promisify(pipeline)

type MethodSignature = {
  path: string
  input: string
  output: string
}

function getMethodSignatures(): { [key: string]: MethodSignature } {
  let result: { [key: string]: MethodSignature } = {}
  for (const methodInfo of SandbarApiService.methods) {
    const { localName, name, I, O } = methodInfo
    const path = getHttpPathForMethod(localName)
    result[name] = { path, input: getTypeName(I), output: getTypeName(O) }
  }
  return result
}

function getTypeName(messageType: IMessageType<object>) {
  const fullName = messageType.typeName
  const [sandbar, v0, name] = fullName.split(".", 3)
  if (sandbar !== "sandbar" || v0 !== "v0") {
    throw new Error("Unexpected values in type names")
  }
  return name
}

function getHttpPathForMethod(method: string) {
  const rule = readMethodOption(
    SandbarApiService,
    method,
    "google.api.http",
    HttpRule
  )
  if (!rule) {
    throw new Error("Expected method ${methodName} to have HTTP bindings")
  }
  if (rule.body != "*") {
    throw new Error(
      "HTTP bindings with any body option other than '*' are not supported"
    )
  }
  if (rule.pattern.oneofKind !== "post") {
    throw new Error("Only POST bindings are supported")
  }

  if (rule.pattern.post.match(/[:*{}=]/)) {
    throw new Error("POST bindings with templates are not supported")
  }

  return rule.pattern.post
}

function methodImpls(
  paths: { [key: string]: MethodSignature },
  repoRoot: string
) {
  const scriptPath = path.relative(repoRoot, __filename)
  const out = new Readable()
  out.push(`// Generated by ${scriptPath}\n`)
  out.push("// Do not edit by hand.\n")
  out.push(`import { IMessageType } from "@protobuf-ts/runtime"\n`)
  out.push("import {\n")
  for (const [_key, { path, input, output }] of Object.entries(paths)) {
    out.push(`  ${input},\n`)
    out.push(`  ${output},\n`)
  }
  out.push(`} from "./sandbar"\n`)
  out.push("export default {\n")
  for (const [key, { path, input, output }] of Object.entries(paths)) {
    out.push(`  "${key}": {\n`)
    out.push(`    path: "${path}",\n`)
    out.push(`    input: ${input} as IMessageType<${input}>,\n`)
    out.push(`    output: ${output} as IMessageType<${output}>,\n`)
    out.push("  },\n")
  }
  out.push("}\n")
  out.push(null)
  return out
}

async function main() {
  const repoRoot = path.resolve(path.join(__dirname, "../.."))
  const outPath = path.join(repoRoot, "src/generated/private/methods.ts")
  const outStream = fs.createWriteStream(outPath, "utf8")
  const paths = getMethodSignatures()
  const readStream = methodImpls(paths, repoRoot)
  await pipelineAsync(readStream, outStream)
}

if (require.main == module) {
  main()
}
